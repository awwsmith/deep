{% extends 'base.html' %}
{% load static %}
{% block extra_css %}
<link href="assets/css/choices.min.css" rel="stylesheet">
<link href="assets/css/nouislider.css" rel="stylesheet">
<!-- all the JS goes here when ready <script src="assets/js/scripts.js" defer></script> -->

{% endblock %}
{% block content %}

<!-- ======= Search Section ======= -->
<section id="search" class="services section-bg" onload="search();">
  <div style="margin-top:80px; min-height: 600px;" class="container" >
    <div id="users">

    <div class="row">
      <div class="col-lg-12 col-md-12">
        <div class="icon-box">
          <div class="icon"><i class="bi bi-search" style="color: #330e40;" no-repeat center center fixed;"></i></div>
         
  
          <input id="search_bar" style="margin-left:10px; width:100%" type="text" name="search" placeholder="Search for a playbook...">
          <p>
            <a class="btn btn-light float-end" onclick="toggleAdvancedSearch();">
              advanced search
            </a>
            
          </p>
          
          <div class="collapse" style="margin-left:12px" id="advancedSearch">
            
            <div class="input-group mb-3"> 
              <span >Record Type:&nbsp;&nbsp;</span> 
        
              <div class="form-check form-check-inline">
                <input class="form-check-input" type="checkbox" id="singlePlay" value="singlePlay" checked>
                <label class="form-check-label" for="singlePlay">Single-Play Playbooks</label>
              </div>
              <div class="form-check form-check-inline">
                <input class="form-check-input" type="checkbox" id="Collections" value="Collections" checked>
                <label class="form-check-label" for="Collections">Collections</label>
              </div>
              <div class="form-check form-check-inline">
                <input class="form-check-input" type="checkbox" id="PlaysinCollections" value="PlaysinCollections" checked>
                <label class="form-check-label" for="PlaysinCollections">Plays in Collection</label>
              </div>
            </div>
            
            <div class="input-group-md">
              <select id="searchSelect" class="input-group form-select form-select-sm">
                <!-- fields=['id',
                  'title_id',
                  'record_type', 
                  'author_id',
                  'collection', 
                  'year', 
                  'deep_id_display', 
                  'greg_full', 
                  #'stc', 
                  'format', 
                  'leaves', 
                  'company_attribution', 
                  'company_id', 
                  'composition_date', 
                  'date_first_publication', 
                  'book_edition', 
                  'play_edition', 
                  'play_type', 
                  'blackletter', 
                  'deep_id', 
                  #'title', 
                  #'greg', 
                  'genre', 
                  'date_first_publication_display', 
                  'date_first_performance', 
                  'company_first_performance', 
                  'total_editions', 
                  'stationers_register', 
                  'british_drama', 
                  'genre_wiggins']) -->
                <option value="">Please select...</option>
                <option value="title" selected>Title</option>
                <option value="author">Author</option>
                <option value="title-page-author">Author (Title-Page Attribution)</option>
                <option value="authorial-status" disabled>Authorial Status (Title-Page Attribution)</option>
                <option value="title-page-modern">All Title-Page Text (modern spelling)</option>
                <option value="title-page-old">All Title-Page Text (old spelling)</option>
                <option value="company-first-performance">Company (First Production)</option>
                <option value="company">Company (Title-Page Attribution)</option>
                <option value="dateofcomp" disabled>Date of First Production</option>
                <option value="theater">Theater (Title-Page Attribution)</option>
                

                <option value="playtype">Play Type</option>
                <option value="dedication">Dedication</option>
                <option value="genre">Genre (Annals)</option>
                <option value="toreader">To the Reader</option>
                <option value="genreplaybook" disabled>Genre (Title-Page Attribution)</option>
                <option value="argument">Argument</option>
                <option value="actor-list">Actor List</option>
                <option value="explicit">Explicit</option>
                <option value="errata">Errata</option>
                <option value="charachter-list">Character List</option>
                <option value="other-paratexts">Other Paratexts</option>
                <option value="paratextual" >All Paratextual Material</option>
                <option value="illustration">Illustration</option>
                <option value="blackletter">Black Letter</option>
                <option value="latinontitle">Latin on Title Page</option>
                <option value="stationer">Stationer</option>
                <option value="printer" >&nbsp;&nbsp;&nbsp;&nbsp;Printer</option>
                <option value="publisher" >&nbsp;&nbsp;&nbsp;&nbsp;Publisher</option>
                <option value="bookseller" >&nbsp;&nbsp;&nbsp;&nbsp;Bookseller</option>
                <option value="commendatory-verses" >Commendatory Verses</option>
                <option value="imprintlocation">Imprint Location</option>
                <option value="dateoffirsted" disabled>Date of First Edition</option>
                <option value="format">Format</option>
                <option value="book_edition">Book edition number</option>
                <option value="play_edition">Play edition number</option>
                <option value="greg_number">Greg Number</option>
                <option value="stc_or_wing">STC / Wing Number</option>
                <option value="first-production">Date of First Production</option>
                <option value="first-edition">Date of First Edition</option>
                <option value="year-published">Year Published</option>

              </select>
              <input id="advancedSearchField" type="text" class="form-control" aria-label="advancedSearchField" aria-describedby="advancedSearchField">
              <select id="choicesSelect" style="display: hide;" class="form-control"></select>
            </div>
            <!-- <style>
              #slider {
    height: 10px;
}

#slider .noUi-connect {
    background: #c0392b;
}

#slider .noUi-handle {
    height: 18px;
    width: 18px;
    top: -5px;
    right: -9px; /* half the width */
    border-radius: 9px;
}

            </style> -->
            <style>.noUi-connect {
              background: #0e0076;
            }</style>
            <div id="spacer" style="height:10px;"></div>
            <div id="slider" style="display:none;margin-top:35px; margin-bottom:20px"></div>
            
            
            
          </div>
        </div>
      </div>
      
  </div>
  
  

  <div  class="row">
    <div class="col-lg-12 col-md-12">
    
      <!-- View Selector  -->
      <div class="form-check form-check-inline">
        <input class="form-check-input" type="radio" name="inlineRadioOptions" id="titleRadio" value="title">
        <label class="form-check-label text-light" for="titleRadio">Title</label>
      </div>
      <div class="form-check form-check-inline">
        <input class="form-check-input" type="radio" name="inlineRadioOptions" id="editionRadio" value="edition" checked>
        <label class="form-check-label text-light" for="editionRadio">Edition</label>
      </div>
      <div class="form-check form-check-inline">
        <input class="form-check-input" type="radio" name="inlineRadioOptions" id="recordRadio" value="record">
        <label class="form-check-label text-light" for="recordRadio">Record</label>
      </div>

      <button id="expandAllButton" class="btn btn-light float-end" onclick="expandAll(this);">Expand all</button>
  <table class="table bg-light text-dark rounded-0">
    <!-- IMPORTANT, class="list" have to be at tbody -->
    <tbody class="list">
      <thead>
        <tr>
          <th class="sort col-2" data-sort="deep_id" scope="col">ID</th>
          <th class="sort col-2" data-sort="year" scope="col">Year</th>
          <th class="sort col-2" data-sort="author" scope="col">Author</th>
          <th class="sort col-7" data-sort="title" scope="col">Title</th>
          <th class="col-1"></th>
        </tr>
      </thead>
      

    </tbody>

  </table>
  

</div>


      
    </div>
    
</div>
</section><!-- End Search Section -->

  
  
{% endblock %}    
    

  
  {% block extra_js %}  
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/list.js/2.3.1/list.min.js"></script>  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/wnumb/1.2.0/wNumb.min.js"></script>  
  <script src="assets/js/choices.min.js"></script>   
  <script src="assets/js/nouislider.js"></script>
  <script>
let slider = document.getElementById('slider');
const min_year = {{ min_year|safe }}
const max_year = {{ max_year|safe }}

var format = {
    //to takes a number, returns a formatted string
    to: function(value) {
      return value.toFixed(0)
    },
    // from takes a formatted string, returns a number.
    from: function (value) {
      return parseInt(value);
    }
};

noUiSlider.create(slider, {
    start: [1522,1651],
    range: { min: min_year, max: max_year },
    connect: true,
    behaviour: 'drag',
    format: format,
    tooltips: true,
    pips: {
        mode: 'steps',
        density: 2,
       
    }

});
slider.noUiSlider.set([min_year,max_year]);

  </script>
 <script>

// fetch data for all records
let item_data;
fetch("../assets/data/item_data.json").then(
        function(u){ return u.json();}
      ).then(
        function(json){
          item_data = json;
        });
        
let index;
fetch("../assets/lunr/search.json").then(
        function(u){ return u.json();}
      ).then(
        function(json){
          index = lunr.Index.load(json);
        });
        
//listen for search_bar
let options = {
      valueNames: ['deep_id','title', 'authors_display', 'year', 'greg_full' ],
      
      // Since there are no elements in the list, this will be used as template.
      item: function(values) { 
        return `<tr id="${values.id}" onclick="expand(this, ${values.id});"><td class="deep_id"></td><td class="year"></td><td class="authors_display"></td><td class="title"></td><td>Expand</td></tr>`
      }
    };
let table = new List('users', options, []);

// temporary until groupBy is added to JS
let groupBy = function(xs, key) {
  return xs.reduce(function(rv, x) {
    (rv[x[key]] = rv[x[key]] || []).push(x);
    return rv;

  }, {});
};




const choicesSelect = document.getElementById("choicesSelect");
choicesSelect.addEventListener("change", (event) => {
  search();
});


const advancedSearch = document.getElementById('advancedSearch');
const search_bar = document.querySelector('#search_bar')

const toggleAdvancedSearch = () => {
  if (advancedSearch.classList.contains("show")) {
    location.reload(); 

  } else {
    search_bar.style.display = "none";
    choicesSelect.style.display = "none";
    advancedSearch.classList.add('show')
    advancedSearchField.style.display = "block";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
}

// set global choices, then update on changes to searchSelect
choices = new Choices(choicesSelect,{
        addItems: false,
        shouldSort: false,
        shouldSortItems: false,
        allowHTML: true,
        position: 'bottom',
        placeholder: 'Select an option',
      })

const searchSelect = document.getElementById("searchSelect");
searchSelect.addEventListener('change', (event) => {
  // this section has two main types, could be shorted with functions
  // one function to create search field, clear choices 
  // one function to set choices, clear search field
  // so TODO when cleaning up
  const is_search_field = val => {
    if (searchSelect.value === val) { 
      slider.style.display = "none";
      advancedSearchField.style.display = "block";
      choices.destroy()
      choicesSelect.style.display = "none";
    }  
  }
  const is_choice_field = val => {
    if (searchSelect.value === val) { 
      // hide advancedSearchField
      slider.style.display = "none";
      advancedSearchField.style.display = "none";
      choicesSelect.style.display = "block";
      choices.init()
      choices.clearChoices()
      // change element to choices field
      choices.setChoices(async () => {
        try {
          const items = await fetch(`/assets/data/${val}.json`);
          return items.json();
          
      } catch (err) {
        console.error(err);
      }
      });
    }
  }
  const is_slider_field = val => {
    advancedSearchField.style.display = "none";
    slider.style.display = "block";
    choices.destroy()
    choicesSelect.style.display = "none";
  }

  if (searchSelect.value === 'title') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'title-page-modern') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'errata') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'paratextual') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'title-page-old') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'title-page-author') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  
  if (searchSelect.value === 'argument') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'latinontitle') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'toreader') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'imprintlocation') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'illustration') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  
  if (searchSelect.value === 'stationer') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'printer') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'publisher') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'bookseller') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'charachter-list') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'commendatory-verses') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'explicit') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'dedication') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'other-paratexts') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'book_edition') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'play_edition') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'actor-list') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'authororial-status') { 
    advancedSearchField.style.display = "block";
    slider.style.display = "none";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'first-production') { 
    // hide choices and text input, display date slider
    advancedSearchField.style.display = "none";
    slider.style.display = "block";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'first-edition') { 
    // hide choices and text input, display date slider
    advancedSearchField.style.display = "none";
    slider.style.display = "block";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  if (searchSelect.value === 'year-published') { 
    // hide choices and text input, display date slider
    advancedSearchField.style.display = "none";
    slider.style.display = "block";
    choices.destroy()
    choicesSelect.style.display = "none";
  }
  
  if (searchSelect.value === 'author') { 
      // hide advancedSearchField
      
      advancedSearchField.style.display = "none";
      slider.style.display = "none";
      choicesSelect.style.display = "block";
      choices.init()
      choices.clearChoices()
      // change element to choices field
      choices.setChoices(async () => {
        try {
          //TODO why fetch json? just use item_data directly
          // get distinct author values from item_data
          const items = await fetch('/assets/data/authors.json');
          return items.json();
          
      } catch (err) {
        console.error(err);
      }
      });
    }
    if (searchSelect.value === 'format') { 
      // hide advancedSearchField
      
      advancedSearchField.style.display = "none";
      slider.style.display = "none";
      choicesSelect.style.display = "block";
      choices.init()
      choices.clearChoices()
      // change element to choices field
      choices.setChoices(async () => {
        try {
          //TODO why fetch json? just use item_data directly
          // get distinct author values from item_data
          const items = await fetch('/assets/data/formats.json');
          return items.json();
          
      } catch (err) {
        console.error(err);
      }
      });
    }

    if (searchSelect.value === 'blackletter') { 
      // hide advancedSearchField
      
      slider.style.display = "none";
      advancedSearchField.style.display = "none";
      choicesSelect.style.display = "block";
      choices.init()
      choices.clearChoices()
      // change element to choices field
      choices.setChoices(async () => {
        try {
          const items = await fetch('/assets/data/blackletter.json');
          return items.json();
          
      } catch (err) {
        console.error(err);
      }
      });
    }
    if (searchSelect.value === 'genre') { 
      // hide advancedSearchField
      advancedSearchField.style.display = "none";
      slider.style.display = "none";
      choicesSelect.style.display = "block";
      choices.init()
      choices.clearChoices()
      // change element to choices field
      choices.setChoices(async () => {
        try {
          const items = await fetch('/assets/data/genre.json');
          return items.json();
          
      } catch (err) {
        console.error(err);
      }
      });
    }
    if (searchSelect.value === 'playtype') {
      advancedSearchField.style.display = "none";
      choicesSelect.style.display = "block";
      slider.style.display = "none";
      choices.init()
      choices.clearChoices()
      // change element to choices field
      choices.setChoices(async () => {
        try {
          const items = await fetch('/assets/data/playtype.json');
          return items.json();
          
      } catch (err) {
        console.error(err);
      }
      });

      
    }
    if (searchSelect.value === 'theater') {
      advancedSearchField.style.display = "none";
      choicesSelect.style.display = "block";
      slider.style.display = "none";
      choices.init()
      choices.clearChoices()
      // change element to choices field
      choices.setChoices(async () => {
        try {
          const items = await fetch('/assets/data/theater.json');
          return items.json();
          
      } catch (err) {
        console.error(err);
      }
      });

      
    }
    if (searchSelect.value === 'company-first-performance') {
      advancedSearchField.style.display = "none";
      choicesSelect.style.display = "block";
      slider.style.display = "none";
      choices.init()
      choices.clearChoices()
      // change element to choices field
      choices.setChoices(async () => {
        try {
          const items = await fetch('/assets/data/first-companies.json');
          return items.json();
          
      } catch (err) {
        console.error(err);
      }
      });

      
    }
    if (searchSelect.value === 'company') {
      advancedSearchField.style.display = "none";
      choicesSelect.style.display = "block";
      slider.style.display = "none";
      choices.init()
      choices.clearChoices()
      // change element to choices field
      choices.setChoices(async () => {
        try {
          const items = await fetch('/assets/data/companies.json');
          return items.json();
          
      } catch (err) {
        console.error(err);
      }
      });

      
    }
  else {
  // restore element to text field
  //const choices = new Choices(advancedSearchField).disable()
 
  };
  search();
}) 
 

function search() {
  table.clear();
  let query = document.querySelector('#search_bar').value;
  if (query){
    query += '~1' //fuzzy search,  1 edit distance
  }

  // handle advanced search
  // first, is advanced search on?
  let searchSelectvalue = document.getElementById('searchSelect').value
  if (advancedSearch.classList.contains('show')) {
    
    if (searchSelectvalue && searchSelectvalue === 'title') {
      if (advancedSearchField.value.length > 0){
        query += ' title:' + advancedSearchField.value + '~1';
        query += ' title_alternative_keywords:' + advancedSearchField.value + '~1' ;
      } 
      
    }
    
    //“Printers” AND “Publishers” AND “Booksellers”
    if (searchSelectvalue && searchSelectvalue === 'stationer') {
      if (advancedSearchField.value.length > 0){
        query += ' stationer_printer:' + advancedSearchField.value + '~1';
        query += ' stationer_publisher:' + advancedSearchField.value + '~1' ;
        query += ' stationer_bookseller:' + advancedSearchField.value + '~1' ;
      } 
      
    }

    //“Dedication” AND “Commendatory Verses” AND “To the Reader” AND “Argument” AND “Character List” AND “Actor List” AND “Explicit” AND “Errata” AND “Other Paratexts”
    if (searchSelectvalue && searchSelectvalue === 'paratextual') {
      if (advancedSearchField.value.length > 0){
        query += ' paratext_dedication:' + advancedSearchField.value + '~1';
        query += ' paratext_commendatory_verses:' + advancedSearchField.value + '~1' ;
        query += ' paratext_to_the_reader:' + advancedSearchField.value + '~1' ;
        query += ' paratext_argument:' + advancedSearchField.value + '~1' ;
        query += ' paratext_actor_list:' + advancedSearchField.value + '~1' ;
        query += ' paratext_charachter_list:' + advancedSearchField.value + '~1' ;
        query += ' title_page_explicit:' + advancedSearchField.value + '~1' ;
        query += ' paratext_errata:' + advancedSearchField.value + '~1' ;
        query += ' paratext_other_paratexts:' + advancedSearchField.value + '~1' ;
    
      } 
      
    }
    if (searchSelectvalue && searchSelectvalue === 'commendatory-verses') {
      if (advancedSearchField.value.length > 0){
        query += 'paratext_commendatory_verses:' + advancedSearchField.value + '~1';
      } 
      
    }

    if (searchSelectvalue && searchSelectvalue === 'title-page-modern') {
      if (advancedSearchField.value.length > 0){
        query += 'title_page_modern_spelling:' + advancedSearchField.value + '~1';
      } 
      
    }
    if (searchSelectvalue && searchSelectvalue === 'imprintlocation') {
      if (advancedSearchField.value.length > 0){
        query += 'title_page_imprint:' + advancedSearchField.value + '~1';
      } 
      
    }
    if (searchSelectvalue && searchSelectvalue === 'title-page-old') {
      if (advancedSearchField.value.length > 0){
        query += 'title_page_title:' + advancedSearchField.value + '~1' ;
        query += ' title_page_author:' + advancedSearchField.value + '~1';
        query += ' title_page_performance:' + advancedSearchField.value + '~1';
        query += ' title_page_latin_motto:' + advancedSearchField.value + '~1';
        query += ' title_page_imprint:' + advancedSearchField.value + '~1';
      } 
      
    }
    if (searchSelectvalue && searchSelectvalue === 'title-page-author') {
      if (advancedSearchField.value.length > 0){
        query += ' title_page_author:' + advancedSearchField.value + '~1';
      } 
      
    }
    if (searchSelectvalue && searchSelectvalue === 'actor-list') {
      if (advancedSearchField.value.length > 0){
        query += ' paratext_actor_list:' + advancedSearchField.value + '~1';
      } 
      
    }
    if (searchSelectvalue && searchSelectvalue === 'explicit') {
      if (advancedSearchField.value.length > 0){
        query += ' title_page_explicit:' + advancedSearchField.value + '~1';
      } 
      
    }

    // title_page_modern_spelling
    
    if (searchSelectvalue && searchSelectvalue === 'toreader') {
      if (advancedSearchField.value.length > 0){
        query += ' paratext_to_the_reader:' + advancedSearchField.value ;
      } 
      
    }
    if (searchSelectvalue && searchSelectvalue === 'argument') {
      if (advancedSearchField.value.length > 0){
        query += ' paratext_argument:' + advancedSearchField.value ;
      } 
      
    }
    if (searchSelectvalue && searchSelectvalue === 'dedication') {
      if (advancedSearchField.value.length > 0){
        query += ' paratext_dedication:' + advancedSearchField.value + '~1';
      } 
      
    }
    if (searchSelectvalue && searchSelectvalue === 'charachter-list') {
      if (advancedSearchField.value.length > 0){
        query += ' paratext_charachter_list:' + advancedSearchField.value + '~1';
      } 
      
    }
    if (searchSelectvalue && searchSelectvalue === 'errata') {
      if (advancedSearchField.value.length > 0){
        query += ' paratext_errata:' + advancedSearchField.value + '~1';
      } 
      
    }
    if (searchSelectvalue && searchSelectvalue === 'other-paratexts') {
      if (advancedSearchField.value.length > 0){
        query += ' paratext_other_paratexts:' + advancedSearchField.value + '~1';
      } 
      
    }
    if (searchSelectvalue && searchSelectvalue === 'illustration') {
      if (advancedSearchField.value.length > 0){
        query += ' title_page_illustration:' + advancedSearchField.value + '~1';
      } 
      
    }
    if (searchSelectvalue && searchSelectvalue === 'latinontitle') {
      if (advancedSearchField.value.length > 0){
        query += ' title_page_latin_motto:' + advancedSearchField.value + '~1';
      } 
      
    }
    
    
  }
  
  search_results = index.search(query)
  results = []
  // logic for title-edition-record filtering 
  let filter = radioHelper();
  if (filter == 'title') {
    search_results.forEach(function(result) {
      results.push(item_data[result.ref])
    });
    let groups = groupBy(results, 'greg');
    
    results = []
    for (i in groups) {
      if (groups[i].length == 1) {
        results.push(groups[i][0])
      } else {
        // sort the group by deep_id, return only lowest deep id
        let d = groups[i].sort((a,b) => a.deep_id - b.deep_id);
        results.push(d[0])
      }
    }
  } else if (filter == 'edition') {
    // load data for each result 
    search_results.forEach(function(result) {
      results.push(item_data[result.ref])
    });
    let groups = groupBy(results, 'greg_middle');
    
    results = []
    for (i in groups) {
      if (groups[i].length == 1) {
        results.push(groups[i][0])
      } else {
        // sort the group by deep_id, return only lowest deep id
        let d = groups[i].sort((a,b) => a.deep_id - b.deep_id);
        // TODO add variant data to d 
        results.push(d[0])
      }
      
      
    };
    
  } else if (filter == 'record') {
    search_results.forEach(function(result) {
      results.push(item_data[result.ref])
    });
  }
  // filter by record type
  if (advancedSearch.classList.contains('show')) {
    if (!singlePlay.checked) {
      results = results.filter(item => item.record_type != 'Single-Play Playbook')
    }
    if (!Collections.checked) {
      results = results.filter(item => item.record_type != 'Collection')
    }
    if (!PlaysinCollections.checked) {
      results = results.filter(item => item.record_type != 'Play in Collection')
    }
  }
  // advanced search filters 
  if (searchSelectvalue && searchSelectvalue === 'greg_number') {
      results = results.filter(item => item.greg_full.includes(advancedSearchField.value))
  }
  if (searchSelectvalue && searchSelectvalue === 'book_edition') {
      results = results.filter(item => item.book_edition.includes(advancedSearchField.value))
  }
  if (searchSelectvalue && searchSelectvalue === 'play_edition') {
      results = results.filter(item => item.play_edition.includes(advancedSearchField.value))
  }
  if (searchSelectvalue && searchSelectvalue === 'stc_or_wing') {
      results = results.filter(item => item.stc.includes(advancedSearchField.value))
  }
  if (searchSelectvalue && searchSelectvalue === 'author') {
      results = results.filter(item => item.author_id.includes(choices.getValue(true)))
  }
  if (searchSelectvalue && searchSelectvalue === 'blackletter') {
      results = results.filter(item => item.blackletter.includes(choices.getValue().label))
  }
  if (searchSelectvalue && searchSelectvalue === 'genre') {
      results = results.filter(item => item.genre.includes(choices.getValue().label))
  }
  if (searchSelectvalue && searchSelectvalue === 'format') {
      results = results.filter(item => item.format.includes(choices.getValue().label))
  }
  if (searchSelectvalue && searchSelectvalue === "playtype") {
      results = results.filter(item => item.play_type.includes(choices.getValue().label))
  }
  if (searchSelectvalue && searchSelectvalue === "company-first-performance") {
      // includes filter to remove items where first company is null
      results = results.filter(x => x.company_first_performance).filter(item => item.company_first_performance.includes(choices.getValue().label))
  }
  if (searchSelectvalue && searchSelectvalue === "company") {
      results = results.filter(item => item.company_id == choices.getValue().value)
  }
  if (searchSelectvalue && searchSelectvalue === 'dedication') {
      results = results.filter(item => item.paratext_dedication.includes(advancedSearchField.value))
  }
  if (searchSelectvalue && searchSelectvalue === 'printer') {
      results = results.filter(item => item.stationer_printer.includes(advancedSearchField.value))
  }
  if (searchSelectvalue && searchSelectvalue === 'publisher') {
      results = results.filter(item => item.stationer_publisher.includes(advancedSearchField.value))
  }
  if (searchSelectvalue && searchSelectvalue === 'bookseller') {
      results = results.filter(item => item.stationer_bookseller.includes(advancedSearchField.value))
  }
  if (searchSelectvalue && searchSelectvalue === 'authorial-status') {
      results = results.filter(item => item.stationer_bookseller.includes(advancedSearchField.value))
  }
  
  if (searchSelectvalue && searchSelectvalue === 'theater') {
      results = results.filter(item => item.theater_type.includes(choices.getValue().label) || item.theater.includes(choices.getValue().label))
      
  }
  if (searchSelectvalue && searchSelectvalue === 'first-production') {
      let current_range = slider.noUiSlider.get()
      let start_range = current_range[0]
      let end_range = current_range[1]
      results = results.filter(item =>  item.composition_date >= start_range && item.composition_date <= end_range)
      
  }
  
  if (searchSelectvalue && searchSelectvalue === 'first-edition') {
      let current_range = slider.noUiSlider.get()
      let start_range = current_range[0]
      let end_range = current_range[1]
      results = results.filter(item =>  item.date_first_publication >= start_range && item.date_first_publication <= end_range)
      
  }

  if (searchSelectvalue && searchSelectvalue === 'year-published') {
      let current_range = slider.noUiSlider.get()
      let start_range = current_range[0]
      let end_range = current_range[1]
      results = results.filter(item =>  item.year_int >= start_range && item.year_int <= end_range)
      
  }
  table.add(results);
  table.update();
};

document.querySelector('#search_bar').addEventListener('keyup', function() {
  search();
});
          
// Section for record type filtering
const singlePlay = document.getElementById('singlePlay') 
singlePlay.addEventListener('change', (event) => {
  search();
});

const Collections = document.getElementById('Collections')
Collections.addEventListener('change', (event) => {
  search();
});

const PlaysinCollections = document.getElementById('PlaysinCollections')
PlaysinCollections.addEventListener('change', (event) => {
  search();
});

const advancedSearchField = document.getElementById('advancedSearchField')
advancedSearchField.addEventListener('keyup', (event) => {
  // console.log(advancedSearchField.value);
  search();
});

// run search when date range slider is changed
slider.noUiSlider.on('change', (event) => {
  // console.log(advancedSearchField.value);
  search();
});

      
function expand(e, id) {
  let data = item_data[id];
  if (data) {
  e.outerHTML = `
  <tr id="${data.id}" onclick="collapse(this, ${data.id});"><td class="deep_id">${data.deep_id}</td><td class="year">${data.year}</td><td class="authors_display">${data.authors_display}</td><td class="title">${data.title}</td><td>Collapse</td>
  
    <tr id="${data.id}-exp">
    <td colspan="5">
      <div class="card" style="width: 100%;">
        
        <div class="card-body">
          <div class="row">
            <div class="col-5">
              <strong>Reference Information</strong>
            </div>
          </div>
          <div class="row">
            <div class="col-5">
              <p><span class="expand">DEEP #:</span> ${data.deep_id}<br>
              <span class="expand">Greg #:</span> ${data.greg_full}<br>
              <span class="expand">STC/WING:</span> ${data.stc}<br>
              <span class="expand">Book Edition:</span> ${data.book_edition}<br>
              <span class="expand">Play Edition:</span> ${data.play_edition}<br>
              <span class="expand">Format:</span> ${data.format}<br>
              <span class="expand">Leaves:</span> ${data.leaves}<br>
              ${typeof data.total_editions === 'undefined' ? '' : '<span class="expand">Total Editions:</span>' + data.total_editions}<br>
              </p>
            </div>
            
    
            <div class="col-7">
              <p><span class="expand">Record Type:</span> ${data.record_type}<br>
              <span class="expand">Play Type:</span> ${data.play_type}<br>
              <span class="expand">Genre (Annals):</span> ${data.genre}<br>
              <span class="expand">Date of First Publication:</span> ${data.date_first_publication}<br>
              <span class="expand">Date of First Performance:</span> ${data.date_first_performance}<br>
              <span class="expand">Theater:</span> ${data.theater}<br>
              <span class="expand">Theater type:</span> ${data.theater_type}<br>
              <span class="expand">Company of First Performance:</span> ${data.company_first_performance}<br>
              <span class="expand">Company Attribution:</span> ${data.company_attribution}</p>
            </div>

          </div>  
         </div>
      </div>

      <div class="card" style="width: 100%; margin-top:2px;">
        <div class="card-body">
          <div class="row">
            <div class="col-12">
              <strong>Title-Page Features</strong>
              <p>
                <span class="expand">Title:</span> ${data.title_page_title}<br>
                <span class="expand">Author:</span> ${data.title_page_author}<br>
                <span class="expand">Performance:</span> ${data.title_page_performance}<br>
                <span class="expand">Imprint:</span> ${data.title_page_imprint}<br>
                <span class="expand">Colophon:</span> ${data.title_page_colophon}<br>
                <span class="expand">Illustration:</span> ${data.title_page_illustration}<br>
                <span class="expand">Latin Motto:</span> ${data.title_page_latin_motto}<br>
                ${data.variant_description === '' ? '' : '<span class="expand">Variants:</span>' + data.variant_description}<br>
              </p>
            </div>
          </div>
        </div>
      </div>

      <div class="card" style="width: 100%; margin-top:2px;">
        <div class="card-body">
          <div class="row">
            <div class="col-12">
              <strong>Paratextual Material</strong>
              <p>
                <span class="expand">Dedication:</span> ${data.paratext_dedication}<br>
                <span class="expand">Commendatory Verses:</span> ${data.paratext_cemmendatory_verses}<br>
                <span class="expand">To the Reader:</span> ${data.paratext_to_the_reader}<br>
                <span class="expand">Errata:</span> ${data.paratext_errata}<br>
                <span class="expand">Argument:</span> ${data.paratext_argument}<br>
                <span class="expand">Charachter List:</span> ${data.paratext_charachter_list}<br>
                <span class="expand">Actor List:</span> ${data.paratext_actor_list}<br>
                <span class="expand">Other:</span> ${data.paratext_other_paratexts}<br>
              </p>
            </div>
          </div>
        </div>
      </div>

      <div class="card" style="width: 100%; margin-top:2px;">
        <div class="card-body">
          <div class="row">
            <div class="col-12">
              <strong>Stationer Information</strong>
              <p>
                <span class="expand">Printer:</span> ${data.stationer_printer}<br>
                <span class="expand">Publisher:</span> ${data.stationer_publisher}<br>
                <span class="expand">Bookseller:</span> ${data.stationer_bookseller}<br>
                <span class="expand">Entries in Stationers' Register:</span> <br>${data.stationer_entries_in_register}<br>
                <span class="expand">Notes:</span> ${data.stationer_additional_notes}<br>
              </p>
            </div>
          </div>
        </div>
      </div>
    </td>
    
  </tr>`;
  }
}

function collapse(e, id) {
  
    let data = item_data[id];
    if (data) {
      e.outerHTML = `
      <tr id="${data.id}" onclick="expand(this, ${data.id});"><td class="deep_id">${data.deep_id}</td><td class="year">${data.year}</td><td class="authors_display">${data.authors_display}</td><td class="title">${data.title}</td><td>Expand</td>`
      let expandCard = document.getElementById(id+'-exp');
      if (expandCard) {
        expandCard.remove();
      }
    }
  }

function expandAll(e) { 
  let items = document.querySelectorAll('tr');
  items.forEach(function(item) {
    expand(item, item.id);
  });
  e.textContent = 'Collapse All';
  e.setAttribute( "onClick", "collapseAll(this)" );
}

function collapseAll(e){
  let items = document.querySelectorAll('tr');
  items.forEach(function(item) {
    if (!item.id.includes("-exp")) {
      collapse(item, item.id);
    }
  });
  e.textContent = 'Expand All';
  e.setAttribute( "onClick", "expandAll(this)" );

};

function radioHelper(){
  if (document.getElementById('titleRadio').checked){
    return 'title';
  }
  else if (document.getElementById('editionRadio').checked){
    return 'edition';
  }
  else if (document.getElementById('recordRadio').checked){
    return 'record';
  }
}

// listen for radio filter changes

document.querySelectorAll('input[type=radio]').forEach(item => {
  item.addEventListener('change', event => {
    search();
  })
})

 </script>
  {% endblock %}
